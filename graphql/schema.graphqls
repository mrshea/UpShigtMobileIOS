"""
A directive used by the Apollo iOS client to annotate operations or fragments that should be used exclusively for generating local cache mutations instead of as standard operations.
"""
directive @apollo_client_ios_localCacheMutation on QUERY | MUTATION | SUBSCRIPTION | FRAGMENT_DEFINITION

"""
A directive used by the Apollo iOS code generation engine to generate custom import statements in operation or fragment definition files. An import statement to import a module with the name provided in the `module` argument will be added to the generated definition file.
"""
directive @import(
  """The name of the module to import."""
  module: String!
) repeatable on QUERY | MUTATION | SUBSCRIPTION | FRAGMENT_DEFINITION

"""Attach extra information to a given type."""
directive @typePolicy(
  """
  A selection set containing fields used to compute the cache key of an object. Referenced fields must have non-nullable scalar types. Order is important.
  """
  keyFields: String!
) on OBJECT | INTERFACE

"""
A directive used by Apollo iOS to map query input data to cache keys of objects.
"""
directive @fieldPolicy(
  """The field you are setting the @fieldPolicy for."""
  forField: String!

  """Set of fields used to compute the cache key."""
  keyArgs: String!
) repeatable on OBJECT | INTERFACE

"""
Directs the executor to defer this fragment when the `if` argument is true or undefined.
"""
directive @defer(
  """Deferred when true or undefined."""
  if: Boolean

  """Unique name"""
  label: String
) on FRAGMENT_SPREAD | INLINE_FRAGMENT

"""DateTime custom scalar type"""
scalar DateTime

type User {
  id: ID!
  clerkId: String!
  firstName: String
  lastName: String
  email: String!
  role: String!
}

type Shift {
  id: ID!
  date: DateTime!
  startTime: String!
  endTime: String!
  peopleNeeded: Int!
  role: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  createdByClerkId: String
  orgId: String
  claimedBy: [ShiftClaim!]!
  availableSpots: Int!
}

type ShiftClaim {
  id: ID!
  shiftId: String!
  shift: Shift!
  clerkId: String!
  claimedAt: DateTime!
  employeeName: String
  employeeEmail: String
}

type TimeOffRequest {
  id: ID!
  clerkId: String!
  orgId: String!
  startDate: DateTime!
  endDate: DateTime!
  reason: String!
  status: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  reviewedBy: String
  reviewedAt: DateTime
  employeeName: String
  employeeEmail: String
}

type TimeEntry {
  id: ID!
  orgId: String!
  shiftId: String
  shift: Shift
  clerkId: String!
  clockInTime: DateTime!
  clockOutTime: DateTime
  clockInLatitude: Float
  clockInLongitude: Float
  clockOutLatitude: Float
  clockOutLongitude: Float
  createdAt: DateTime!
  updatedAt: DateTime!
  hoursWorked: Float
  employeeName: String
  employeeEmail: String
}

type ClockStatus {
  isClockedIn: Boolean!
  activeEntry: TimeEntry
}

type Query {
  me: User
  shifts(startDate: DateTime, endDate: DateTime): [Shift!]!
  shift(id: ID!): Shift
  myShifts: [ShiftClaim!]!
  timeOffRequests(isAdmin: Boolean!): [TimeOffRequest!]!
  myTimeOffRequests: [TimeOffRequest!]!
  timeEntries(isAdmin: Boolean!, employeeId: String, startDate: DateTime, endDate: DateTime): [TimeEntry!]!
  myTimeEntries(startDate: DateTime, endDate: DateTime): [TimeEntry!]!
  clockStatus: ClockStatus!
}

type Mutation {
  createShift(date: DateTime!, startTime: String!, endTime: String!, peopleNeeded: Int!, role: String!): Shift!
  claimShift(shiftId: ID!): ShiftClaim!
  unclaimShift(shiftId: ID!): Boolean!
  deleteShift(id: ID!): Boolean!
  createTimeOffRequest(startDate: DateTime!, endDate: DateTime!, reason: String!): TimeOffRequest!
  updateTimeOffRequestStatus(requestId: ID!, status: String!): TimeOffRequest!
  deleteTimeOffRequest(id: ID!): Boolean!
  clockIn(shiftId: ID, latitude: Float, longitude: Float): TimeEntry!
  clockOut(latitude: Float, longitude: Float): TimeEntry!
}